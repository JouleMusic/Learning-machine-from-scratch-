# 协同过滤算法(Collaborative filtering algorithm)
## 什么是协同过滤算法
顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使 自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。

协同过滤是利用集体智慧的一个典型方法。要理解什么是协同过滤 (Collaborative Filtering, 简称 CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。

协同过滤一般是在海量的用户中发掘出一小部分和你品位比较类似的，在协同过滤中，这些用户成为邻居，然后根据他们喜欢的其他东西组织成一个排序的目录作为推荐给你。当然其中有一个核心的问题：

1. 如何确定一个用户是不是和你有相似的品位？
2. 如何将邻居们的喜好组织成一个排序的目录？

协同过滤相对于集体智慧而言，它从一定程度上保留了个体的特征，就是你的品位偏好，所以它更多可以作为个性化推荐的算法思想。可以想象，这种推荐策略在 Web 2.0 的长尾中是很重要的，将大众流行的东西推荐给长尾中的人怎么可能得到好的效果，这也回到推荐系统的一个核心问题：了解你的用户，然后才能给出更好的推荐。

## 基于邻域的算法
基于邻域的算法是推荐系统中最基本的算法。基于邻域的算法分为两大类，一类是基于用户的协同过滤算法，另一类是 基于物品的协同过滤算法。

## 基于用户的协同过滤算法

### 基于用户的协同过滤算法步骤
基于用户的协同过滤算法主要包括两个步骤:
1. 找到和目标用户兴趣相似的用户集合。
2. 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。

#### 步骤1
步骤(1)的关键就是计算两个用户的兴趣相似度。这里，协同过滤算法主要利用行为计算兴趣的相似度。

计算相似度的方法主要有：
1. [余弦相似性，Cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity)；
2. [Jaccard similarity](https://en.wikipedia.org/wiki/Jaccard_index)；
3. 均方根相似度(Mean Squared Difference similarity，msd)其实就是欧式距离；
4. [Pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient)；

通过计算用户行为间的相似度，从而找到与用户兴趣最相近的K个用户，完成步骤1。

#### 步骤2
计算用户u最感兴趣的N个物品（item）：
1. 找到步骤1获得的K个用户感兴趣的物品集S，V是步骤1找出的K个用户的集合。
2. 遍历S中的每个物品，计算用户u对该物品的兴趣度。
3. 兴趣度的计算方法是：sum((Wuv * rvi) for v, rvi in V) for i in S。Wuv表示用户u和用户v的相似度，rvi表示用户v的打分。
```
    # init S
    S = set()
    for v in V:
        for i in v.items():
            if i not in u.items():
                S.add(i)
    # iter S
    pui = dict()
    for s in S:
        for v in V:
            rate = v[s.iid]['rate']
            pui[s.iid] += W[u.iid][v.iid]* rate
    # 给pui排序，找到topN
```

## 基于物品的协同过滤(item-based collaborative filtering)

随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系。其次，基于用户的协同过滤很难对推荐结果作出解释。


基于物品的协同过滤算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。

### 可解释性 
基于物品的协同过滤算法可以利用用户的历史行为给推荐结果提供推荐解释，比如给用户推荐《天龙八部》的解释可以是因为用户之前喜欢《射雕英雄传》。

### 基于物品的协同过滤算法步骤
基于物品的协同过滤算法主要分为两步。
1. 计算物品之间的相似度。
2. 根据物品的相似度和用户的历史行为给用户生成推荐列表。

#### 步骤1
可以用下面的公式定义物品的相似度:

```
# Ni 表示喜欢物品i的用户集合
Ni = set()

# Nj 表示喜欢物品j的用户集合
Nj = set()

# Wij表示物品i和物品j的相似度
Wij = len(Ni & Nj) / len(Ni)
```

上述公式虽然看起来很有道理，但是却存在一个问题。如果物品j很热门，很多人都喜欢，
那么Wij就会很大，接近1。因此，该公式会造成任何物品都会和热门的物品有很大的相似度，这 对于致力于挖掘长尾信息的推荐系统来说显然不是一个好的特性。为了避免推荐出热门的物品， 可以用下面的公式:

```
# Ni 表示喜欢物品i的用户集合
Ni = set()

# Nj 表示喜欢物品j的用户集合
Nj = set()

# Wij表示物品i和物品j的相似度
Wij = len(Ni & Nj) / math.sqrt(len(Ni) * len(Nj))
```

这个公式惩罚了物品j的权重，因此减轻了热门物品会和很多物品相似的可能性。

#### 步骤2

下图是一个基于物品推荐的简单例子。该例子中，用户喜欢《C++ Primer中文版》和《编程之美》两本书。然后ItemCF会为这两本书分别找出和它们最相似的3本书，然后根据公式的定 义计算用户对每本书的感兴趣程度。比如，ItemCF给用户推荐《算法导论》，是因为这本书和《C++ Primer中文版》相似，相似度为0.4，而且这本书也和《编程之美》相似，相似度是0.5。考虑到用户对《C++ Primer中文版》的兴趣度是1.3，对《编程之美》的兴趣度是0.9，那么用户对《算法导论》的兴趣度就是1.3 × 0.4 + 0.9×0.5 = 0.97。

![](https://github.com/bobkentt/Learning-machine-from-scratch-pic/blob/master/practice/pic/QQ20170823-195556.png)

## 基于用户的协同过滤和基于物品的协同过滤的综合比较

首先回顾一下UserCF算法和ItemCF算法的推荐原理。UserCF给用户推荐那些和他有共同兴 趣爱好的用户喜欢的物品，而ItemCF给用户推荐那些和他之前喜欢的物品类似的物品。从这个算 法的原理可以看到，UserCF的推荐结果着重于反映和用户兴趣相似的小群体的热点，而ItemCF 的推荐结果着重于维系用户的历史兴趣。换句话说，UserCF的推荐更社会化，反映了用户所在的 6 小型兴趣群体中物品的热门程度，而ItemCF的推荐更加个性化，反映了用户自己的兴趣传承。




